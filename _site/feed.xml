<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-08T15:48:04+08:00</updated><id>http://localhost:4000/</id><title type="html">Lionel PlayGround</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">kubernetes的决策分离</title><link href="http://localhost:4000/kubernetes/2018/03/08/kubernetes-decision-and-making.html" rel="alternate" type="text/html" title="kubernetes的决策分离" /><published>2018-03-08T09:36:54+08:00</published><updated>2018-03-08T09:36:54+08:00</updated><id>http://localhost:4000/kubernetes/2018/03/08/kubernetes-decision-and-making</id><content type="html" xml:base="http://localhost:4000/kubernetes/2018/03/08/kubernetes-decision-and-making.html">&lt;h1 id=&quot;鱼与熊掌&quot;&gt;鱼与熊掌&lt;/h1&gt;
&lt;p&gt;笼统了解了一下Kubernetes的架构设计，发现它的架构非常有意思，在一些方面实现了一定程度上得的“鱼与熊掌得兼”：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;系统本身高复杂——对外接口简单清晰&lt;/li&gt;
  &lt;li&gt;高访问——没有性能瓶颈&lt;/li&gt;
  &lt;li&gt;高可用的特性——实现上的低成本&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;总之就是很牛逼了&lt;/p&gt;

&lt;h2 id=&quot;kubernetes中枢部分的决策分离&quot;&gt;Kubernetes中枢部分的“决”“策”分离&lt;/h2&gt;

&lt;p&gt;Kubernetes的组件可以大致分为俩部分：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;负责整个集群的【中枢】，中枢的首长是【api server】&lt;/li&gt;
  &lt;li&gt;负责单个Node的【地方】，地方的行政长官是【kubelet】&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;中枢部分又包括了很多组件，但对外，不论是使用者，还是对地方，都只呈现出一个api server&lt;/p&gt;

&lt;p&gt;所有用户对集群的指令，和所有kubelet的交互，都由api server完成&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Kubernetes通过“决”与“策”的分离，减轻了api server的负担&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;api server负责【决】，所有引起集群状态变更的动作，都经过api server并由其负责落地（存储到etcd中），只有api server由读写etcd的权限&lt;/p&gt;

&lt;p&gt;专门的参谋团负责【策】，其中最主要的俩个就是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;controller manager&lt;/li&gt;
  &lt;li&gt;scheduler&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如一个新的pod需要运行，api server会让scheduler负责考虑pod该运行在哪个Node上&lt;/p&gt;

&lt;p&gt;scheduler考虑清楚后把方案提交给api server，api server对方案做持久化&lt;/p&gt;

&lt;p&gt;对应Node上的kubelet去运行pod实例&lt;/p&gt;

&lt;h2 id=&quot;kubernetes-client订阅机制&quot;&gt;Kubernetes Client订阅机制&lt;/h2&gt;
&lt;p&gt;Kubernetes中组件的交互很频繁，但因为做了“决”“策”分离，负责具体事务的【中枢】职能官既不与etcd通信，也不与【地方】kubelet通信&lt;/p&gt;

&lt;p&gt;所以Kubernetes的网络通信模型最后变成了所有组件都要而且只要与api server通信，一定程度上降低了复杂度和全局的通信负担，api server也变相承担了全局“锁”的作用，维持通信上的先后顺序&lt;/p&gt;

&lt;p&gt;但是如此一来api server似乎负担会很重，宕机的可能性和成本都变大了&lt;/p&gt;

&lt;p&gt;所以Kubernetes使用了带hook的client&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;提供一个api server的client，这个client带一个hook，使用者在api server上注册订阅，有相关的状态变动时，api server通过hook发布到使用者（订阅者）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;相当于【中枢】不维护飞鸽，不需要知道飞鸽的目的地，而是【地方】和【中枢】的职能官自己在【中枢】处放一只飞鸽&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这个设计带来的好处：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;双向通信变成单向通信，api server不需要感知到各个组件，也不需要实现各个组件的client&lt;/li&gt;
  &lt;li&gt;减少握手成本和用于勘察状态的通信&lt;/li&gt;
  &lt;li&gt;最关键的一点，减轻了api server的通信成本&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;kubernetes高可用&quot;&gt;Kubernetes高可用&lt;/h2&gt;
&lt;p&gt;软件系统的高可用，通常是通过冗余和高频的通信和保持状态一致&lt;/p&gt;

&lt;h3 id=&quot;中枢部分&quot;&gt;中枢部分&lt;/h3&gt;
&lt;p&gt;api server支持分布式&lt;/p&gt;

&lt;p&gt;其它职能组件原生不支持，但是在api server分布式的场景中，可以在每个api server的Node上
运行一套职能组件的副本，职能组件的多副本间是主备关系&lt;/p&gt;

&lt;p&gt;但是只有api server知道哪个副本是主副本，因为副本之间没有通信&lt;/p&gt;

&lt;p&gt;api server上的状态变动会通知到所有副本，但它只会采用主副本提供回来的方案，主副本异常后，api server再从新选择一个主副本&lt;/p&gt;

&lt;p&gt;职能组件以此来实现了伪分布式的高可用&lt;/p&gt;

&lt;h3 id=&quot;kubelet&quot;&gt;kubelet&lt;/h3&gt;
&lt;p&gt;kubelet通常是以系统的service形式存在的，所以kubelet的高可用一般是有操作系统保证&lt;/p&gt;</content><author><name></name></author><summary type="html">鱼与熊掌 笼统了解了一下Kubernetes的架构设计，发现它的架构非常有意思，在一些方面实现了一定程度上得的“鱼与熊掌得兼”： 系统本身高复杂——对外接口简单清晰 高访问——没有性能瓶颈 高可用的特性——实现上的低成本</summary></entry><entry><title type="html">Zookeeper的一致性与选举!</title><link href="http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election.html" rel="alternate" type="text/html" title="Zookeeper的一致性与选举!" /><published>2018-03-07T09:36:54+08:00</published><updated>2018-03-07T09:36:54+08:00</updated><id>http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election</id><content type="html" xml:base="http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election.html">&lt;h1 id=&quot;一致性算法paxos&quot;&gt;一致性算法Paxos&lt;/h1&gt;
&lt;p&gt;提到一致性算法（协议），无法绕开Paxos——Paxos Wiki，这是过去十年分布式一致性协议上的主流算法&lt;/p&gt;

&lt;p&gt;首先将议员的角色分为proposers，acceptors，和learners（允许身兼数职）。proposers提出提案，提案信息包括提案编号和提议的value；acceptor收到提案后可以接受（accept）提案，若提案获得多数acceptors的接受，则称该提案被批准（chosen）；learners只能“学习”被批准的提案。划分角色后，就可以更精确的定义问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;决议（value）只有在被proposers提出后才能被批准（未经批准的决议称为“提案（proposal）”）&lt;/li&gt;
  &lt;li&gt;在一次Paxos算法的执行实例中，只批准（chosen）一个value&lt;/li&gt;
  &lt;li&gt;learners只能获得被批准（chosen）的value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以上3个约束基础上，强化约束如下既可得到Paxos算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P1：一个acceptor必须接受（accept）第一次收到的提案
    &lt;ul&gt;
      &lt;li&gt;P1a：当且仅当acceptor没有回应过编号大于n的prepare请求时，acceptor接受（accept）编号为n的提案&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;P2：一旦一个具有value v的提案被批准（chosen），那么之后批准（chosen）的提案必须具有value v
    &lt;ul&gt;
      &lt;li&gt;P2a：一旦一个具有value v的提案被批准（chosen），那么之后任何acceptor再次接受（accept）的提案必须具有value v&lt;/li&gt;
      &lt;li&gt;P2b：一旦一个具有value v的提案被批准（chosen），那么以后任何proposer提出的提案必须具有value v&lt;/li&gt;
      &lt;li&gt;P2c：如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于n的任何提案，要么他们已经接受（accept）的所有编号小于n的提案中编号最大的那个提案具有value v&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Paxos依靠vote上的多数派原则，进行演化收敛——副作用就是当一个主题的proposal有多个value时收敛速度下降快，比如全局leader election&lt;/p&gt;

&lt;h1 id=&quot;zab&quot;&gt;Zab&lt;/h1&gt;
&lt;p&gt;而Zookeeper基于Paxos进行了改造——Zab（Zookeeper Automatic BroadCast Protocol）&lt;/p&gt;

&lt;p&gt;Zab vs. Paxos&lt;/p&gt;

&lt;p&gt;简单来讲，Zab采用了Paxos所使用的vote机制——多数派原则和消息传递特征&lt;/p&gt;

&lt;p&gt;而从设计上，Paxos是针对state machine replication，既有限状态机，无法优秀的支持primary-backup replication&lt;/p&gt;

&lt;p&gt;俩种replication的区别在于state machine的state set和state change是确定的，需要一致的是各个replications对state change request的一致顺序处理，而primary-back是指state change from last state，而且state set往往是没有边界的，也就不存在清晰的state change set
前者的replica在某一个时间点可能状态不同，但是保证在定序执行完所有request后状态一致，要求一致性算法做到request的定序（即使request是分散凌乱的），而后者是状态一个接一个的primary updates，要求一致性算法做到在updates过程中的容错
Paxos如果想应用在primary-backup replication中，必须以primary为leader，然后可以通过一次只接受一个request来保证primary update动作的原子性，但是这样会非常损耗性能&lt;/p&gt;

&lt;p&gt;所以Zab对Paxos leader模式做的改进有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从历史中恢复——保证了request的uncommit与commit状态&lt;/li&gt;
  &lt;li&gt;增加prefix ordering properties以支持primary/backup的并发性能——所有request被杂乱地送往leader&lt;/li&gt;
  &lt;li&gt;在更换leader期间保证proposal是定序的——增加了数据同步和数据广播&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而Zab leader选择的依据，则是ZXid最高，意味着处理过最多的request，leader election本质上是全局范围内最大ZXid持有者的收敛：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;leader election（认知范围内收敛完成后，资历最老的带头闹革命）&lt;/li&gt;
  &lt;li&gt;建立epoch（向全国确立新年号，以保证没有前朝皇室余孽，如果没有收到所有人的确立回复，返回leader election）&lt;/li&gt;
  &lt;li&gt;leader与follower同步（整顿内务，把前朝的帐算清楚，确定一下哪些follower可以上岗哪些不行，follower差不多就绪了，开始挂着新epoch搞生产）&lt;/li&gt;
  &lt;li&gt;数据广播（日常工作，发号施令，以[ZXid, data]向follower传达）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（貌似和kafka log replication的模式略相似）&lt;/p&gt;</content><author><name></name></author><summary type="html">一致性算法Paxos 提到一致性算法（协议），无法绕开Paxos——Paxos Wiki，这是过去十年分布式一致性协议上的主流算法</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-03-06T09:36:54+08:00</published><updated>2018-03-06T09:36:54+08:00</updated><id>http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>