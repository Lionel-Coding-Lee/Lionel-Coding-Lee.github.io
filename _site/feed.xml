<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.7.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-03-07T17:52:06+08:00</updated><id>http://localhost:4000/</id><title type="html">Lionel PlayGround</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">Zookeeper的一致性与选举!</title><link href="http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election.html" rel="alternate" type="text/html" title="Zookeeper的一致性与选举!" /><published>2018-03-07T09:36:54+08:00</published><updated>2018-03-07T09:36:54+08:00</updated><id>http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election</id><content type="html" xml:base="http://localhost:4000/zookeeper/2018/03/07/zookeeper-consistent-and-election.html">&lt;h1 id=&quot;一致性算法paxos&quot;&gt;一致性算法Paxos&lt;/h1&gt;
&lt;p&gt;提到一致性算法（协议），无法绕开Paxos——Paxos Wiki，这是过去十年分布式一致性协议上的主流算法&lt;/p&gt;

&lt;p&gt;首先将议员的角色分为proposers，acceptors，和learners（允许身兼数职）。proposers提出提案，提案信息包括提案编号和提议的value；acceptor收到提案后可以接受（accept）提案，若提案获得多数acceptors的接受，则称该提案被批准（chosen）；learners只能“学习”被批准的提案。划分角色后，就可以更精确的定义问题：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;决议（value）只有在被proposers提出后才能被批准（未经批准的决议称为“提案（proposal）”）&lt;/li&gt;
  &lt;li&gt;在一次Paxos算法的执行实例中，只批准（chosen）一个value&lt;/li&gt;
  &lt;li&gt;learners只能获得被批准（chosen）的value&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在以上3个约束基础上，强化约束如下既可得到Paxos算法&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;P1：一个acceptor必须接受（accept）第一次收到的提案
    &lt;ul&gt;
      &lt;li&gt;P1a：当且仅当acceptor没有回应过编号大于n的prepare请求时，acceptor接受（accept）编号为n的提案&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;P2：一旦一个具有value v的提案被批准（chosen），那么之后批准（chosen）的提案必须具有value v
    &lt;ul&gt;
      &lt;li&gt;P2a：一旦一个具有value v的提案被批准（chosen），那么之后任何acceptor再次接受（accept）的提案必须具有value v&lt;/li&gt;
      &lt;li&gt;P2b：一旦一个具有value v的提案被批准（chosen），那么以后任何proposer提出的提案必须具有value v&lt;/li&gt;
      &lt;li&gt;P2c：如果一个编号为n的提案具有value v，那么存在一个多数派，要么他们中所有人都没有接受（accept）编号小于n的任何提案，要么他们已经接受（accept）的所有编号小于n的提案中编号最大的那个提案具有value v&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Paxos依靠vote上的多数派原则，进行演化收敛——副作用就是当一个主题的proposal有多个value时收敛速度下降快，比如全局leader election&lt;/p&gt;

&lt;h1 id=&quot;zab&quot;&gt;Zab&lt;/h1&gt;
&lt;p&gt;而Zookeeper基于Paxos进行了改造——Zab（Zookeeper Automatic BroadCast Protocol）&lt;/p&gt;

&lt;p&gt;Zab vs. Paxos&lt;/p&gt;

&lt;p&gt;简单来讲，Zab采用了Paxos所使用的vote机制——多数派原则和消息传递特征&lt;/p&gt;

&lt;p&gt;而从设计上，Paxos是针对state machine replication，既有限状态机，无法优秀的支持primary-backup replication&lt;/p&gt;

&lt;p&gt;俩种replication的区别在于state machine的state set和state change是确定的，需要一致的是各个replications对state change request的一致顺序处理，而primary-back是指state change from last state，而且state set往往是没有边界的，也就不存在清晰的state change set
前者的replica在某一个时间点可能状态不同，但是保证在定序执行完所有request后状态一致，要求一致性算法做到request的定序（即使request是分散凌乱的），而后者是状态一个接一个的primary updates，要求一致性算法做到在updates过程中的容错
Paxos如果想应用在primary-backup replication中，必须以primary为leader，然后可以通过一次只接受一个request来保证primary update动作的原子性，但是这样会非常损耗性能&lt;/p&gt;

&lt;p&gt;所以Zab对Paxos leader模式做的改进有：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;从历史中恢复——保证了request的uncommit与commit状态&lt;/li&gt;
  &lt;li&gt;增加prefix ordering properties以支持primary/backup的并发性能——所有request被杂乱地送往leader&lt;/li&gt;
  &lt;li&gt;在更换leader期间保证proposal是定序的——增加了数据同步和数据广播&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而Zab leader选择的依据，则是ZXid最高，意味着处理过最多的request，leader election本质上是全局范围内最大ZXid持有者的收敛：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;leader election（认知范围内收敛完成后，资历最老的带头闹革命）&lt;/li&gt;
  &lt;li&gt;建立epoch（向全国确立新年号，以保证没有前朝皇室余孽，如果没有收到所有人的确立回复，返回leader election）&lt;/li&gt;
  &lt;li&gt;leader与follower同步（整顿内务，把前朝的帐算清楚，确定一下哪些follower可以上岗哪些不行，follower差不多就绪了，开始挂着新epoch搞生产）&lt;/li&gt;
  &lt;li&gt;数据广播（日常工作，发号施令，以[ZXid, data]向follower传达）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;（貌似和kafka log replication的模式略相似）&lt;/p&gt;</content><author><name></name></author><summary type="html">一致性算法Paxos 提到一致性算法（协议），无法绕开Paxos——Paxos Wiki，这是过去十年分布式一致性协议上的主流算法</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2018-03-06T09:36:54+08:00</published><updated>2018-03-06T09:36:54+08:00</updated><id>http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/jekyll/update/2018/03/06/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;https://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name></name></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>